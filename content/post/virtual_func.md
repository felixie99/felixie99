---
title:       "虚函数"
subtitle:    ""
description: ""
date:        2023-05-28T20:21:25+08:00
author:      ""
image:       ""
tags:        ["cpp"]
categories:  ["Tech" ]
---

# 虚函数

**c++作为面向对象的语言，主要有三大特性：继承、封装、多态。而多态的实现离不开虚函数的定义，虚函数的实现离不开虚函数表**  
简而言之：用父类的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。而具体调用哪个成员函数取决于运行时对象的实际类型，而非指针或引用的类型。  
例如：
```c++
A* a = new B(); // A实现了虚函数
```
调用过程：通过对象指针A* 找到子类B的对象,子类B对象中有虚函数表指针vptr, 然后通过虚函数表指针找到虚函数
> 虚函数表在编译期间由编译器创建，虚函数指针在对象被创建时被初始化，通常作为对象的第一个成员参数。  

由于**被执行的代码必须和调用函数的对象的动态类型一致**，即我们使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正的作用对象是什么类型，需要在运行时才知道指针指向的对象是什么类，从而确定调用什么类的虚函数，所以也称为“运行时多态”  
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类：
- 静态多态通过重载、模板来实现
- 动态多态通过虚函数体现
    通过虚类指针指向派生类对象，再由派生类对象中的虚函数表指针找到派生类的虚函数表，虚函数表中有虚函数指针指向对应的函数。  
    所以实现动态多态必须满足两个条件：
    - 必须通过基类的指针或引用调用虚函数（如果用派生类指针直接指向派生类，那么编译时就能确定对象类型，就成了静态绑定）
    - 被调用的函数必须是虚函数，且必须完成对基类虚函数的重写（如果不是虚函数，虚函数表中就没有这个函数；如果没有对基类虚函数重写，那么子类虚函数表中的虚函数仍然是基类虚函数的版本）

# 虚函数表  
当一个类中含有虚函数（无论是直接定义，还是继承获得），就会为该类生产一个虚函数表。  
这个表中包含了类的所有虚函数的地址，并且在用类构造对象时，会在对象的内存布局中插入一个隐藏的指针（虚函数表指针）。  

[C++虚函数的实现基本原理](https://jacktang816.github.io/post/virtualfunction/#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83)  

[虚函数表](https://zhuanlan.zhihu.com/p/365765942)  

[编程指北-虚函数表](https://csguide.cn/cpp/object_oriented/virtual_function.html#c-对象模型)

## 虚函数的应用注意事项
- 内联函数 (inline)
虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用。默认地，类中定义的所有函数，除了虚函数之外，会隐式地或自动地当成内联函数(注意：内联只是对于编译器的一个建议，编译器可以自己决定是否进行内联).
无论何时，使用基类指针或引用来调用虚函数，它都不能为内联函数(因为调用发生在运行时)。但是，无论何时，使用类的对象(不是指针或引用)来调用时，可以当做是内联，因为编译器在编译时确切知道对象是哪个类的。

- 静态成员函数 (static)
static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。此外静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针，从而导致两者调用方式不同。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。**虚函数的调用关系：this -> vptr -> vtable ->virtual function**，对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。

- 构造函数 (constructor)
如果构造函数是虚函数，那么就需要通过**this -> vptr -> vtable ->virtual function**的调用关系来找到构造函数，但是此时对象都还没构造，this指针根本不存在。  

此外构造函数不仅不能是虚函数。而且在构造函数中调用虚函数，首先会调用父类的构造函数，因为自己还没有构造好, 所以调用的虚函数其实是父类的虚函数，会造成意想不到的结果。

- 析构函数 (deconstructor)
对于可能作为基类的类的析构函数要求就是virtual的。因为如果不是virtual的，派生类析构的时候调用的是基类的析构函数，而基类的析构函数只要对基类部分进行析构，从而可能导致派生类部分出现内存泄漏问题。

- 纯虚函数
析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

- 成员模板函数
    成员模板函数不能是virtual的，因为c++的编译和链接是分离的
    - 在链接之前，各个编译单元对于其他编译单元是一无所知的
    - 一个模版函数最后会被实现成多少函数，要等整个程序（所有的编译单元）全部被编译完成才知道
    - 虚函数的实现依靠虚函数表，一个类的内存布局（或者说虚函数的内存布局）需要在这个类编译完成时就能被完全确定
    所以当一个虚函数是模板函数时，是不能知道到底有多少个虚函数，无法生成一个确定的虚函数表条目

# 纯虚函数  

当我们不希望用户创建一个类对象，只希望它的函数被派生类中定义和实现时，我们可以将函数定义为纯虚函数，而含有纯虚函数（或未经覆盖直接继承）的类是抽象基类，类似java中的接口。
```c++
class AbstractClass {
public:
    virtual void PureVirtualFunction() = 0; // 纯虚函数声明
};
```
我们可以为纯虚函数提供定义，但函数体必须定义在类的外部

# 虚函数和纯虚函数的区别

虚函数和纯虚函数在C++中都是用于支持多态性的机制，它们的主要区别如下：

1. **虚函数**：虚函数是在基类中使用关键字 `virtual` 声明的函数，它在派生类中可以被重写。虚函数有默认实现，即基类中的实现，当它在派生类中被重写时，可以通过基类指针或引用调用派生类的版本。

2. **纯虚函数**：纯虚函数是在基类中使用 `virtual` 关键字声明，并使用 `= 0` 来标识的函数。纯虚函数没有默认实现，它在基类中只提供声明，不提供具体的实现。纯虚函数的存在使得基类变成了抽象类，不能直接实例化。派生类必须提供纯虚函数的实现，否则该派生类也将成为抽象类。
举例来说：

```cpp
class Base {
public:
    virtual void func() { 
        // 虚函数，有默认实现
    }

    virtual void pureFunc() = 0; 
    // 纯虚函数，没有默认实现，派生类必须提供实现
};
```

总的来说，虚函数和纯虚函数都提供了多态性，虚函数提供了默认的实现，而纯虚函数则强制派生类提供实现。