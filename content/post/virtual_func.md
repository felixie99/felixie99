---
title:       "虚函数"
subtitle:    ""
description: ""
date:        2023-05-28T20:21:25+08:00
author:      ""
image:       ""
tags:        ["cpp"]
categories:  ["Tech" ]
---

# 虚函数

**c++作为面向对象的语言，主要有三大特性：继承、封装、多态。而多态的实现离不开虚函数的定义，虚函数的实现离不开虚函数表**  
简而言之：用父类的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。而具体调用哪个成员函数取决于运行时对象的实际类型，而非指针或引用的类型。  
例如：
```c++
A* a = new B(); // A实现了虚函数
```
调用过程：通过对象指针A* 找到子类B的虚函数表指针vptr 然后通过虚函数表指针找到虚函数  通过虚函数表中的虚函数指针找到对应的虚函数  
由于**被执行的代码必须和调用函数的对象的动态类型一致**，即我们使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正的作用对象是什么类型，需要在运行时才知道指针指向的对象是什么类，从而确定调用什么类的虚函数，所以也称为“运行时多态”  
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类：
- 静态多态通过重载、模板来实现
- 动态多态通过虚函数体现

# 虚函数表
[C++虚函数的实现基本原理](https://jacktang816.github.io/post/virtualfunction/#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83)
[虚函数表](https://zhuanlan.zhihu.com/p/365765942)

## 纯虚函数  

当我们不希望用户创建一个类对象，只希望它的函数被派生类中定义和实现时，我们可以将函数定义为纯虚函数，而含有纯虚函数（或未经覆盖直接继承）的类是抽象基类，类似java中的接口。
```c++
class AbstractClass {
public:
    virtual void PureVirtualFunction() = 0; // 纯虚函数声明
};
```
我们可以为纯虚函数提供定义，但函数体必须定义在类的外部

## 虚函数和纯虚函数的区别

虚函数和纯虚函数在C++中都是用于支持多态性的机制，它们的主要区别如下：

1. **虚函数**：虚函数是在基类中使用关键字 `virtual` 声明的函数，它在派生类中可以被重写。虚函数有默认实现，即基类中的实现，当它在派生类中被重写时，可以通过基类指针或引用调用派生类的版本。

2. **纯虚函数**：纯虚函数是在基类中使用 `virtual` 关键字声明，并使用 `= 0` 来标识的函数。纯虚函数没有默认实现，它在基类中只提供声明，不提供具体的实现。纯虚函数的存在使得基类变成了抽象类，不能直接实例化。派生类必须提供纯虚函数的实现，否则该派生类也将成为抽象类。
举例来说：

```cpp
class Base {
public:
    virtual void func() { 
        // 虚函数，有默认实现
    }

    virtual void pureFunc() = 0; 
    // 纯虚函数，没有默认实现，派生类必须提供实现
};
```

总的来说，虚函数和纯虚函数都提供了多态性，虚函数提供了默认的实现，而纯虚函数则强制派生类提供实现。