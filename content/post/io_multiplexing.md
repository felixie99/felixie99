---
title:       "IO多路复用"
subtitle:    ""
description: ""
date:        2023-05-29T22:06:14+08:00 
author:      ""
image:       ""
tags:        ["网络编程"]
categories:  ["Tech" ]
katex:       false
---

我们以「如何服务更多的用户」这一问题引入IO多路复用 

如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？

并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。

从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。

不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。

## 阻塞等待(BIO模型)
---

### 单任务
在网络环境中客户端和服务端使用Socket进行通信，它基本上只能一对一通信，因为使用的是「同步阻塞」的方式，当服务器在还没处理完一个客户端的网络IO时， 或者读写操作发送阻塞时，其他客户端时无法与服务器连接的。  
```c++
int lfd = socket(...);
bind(lfd, ...);
listen(lfd, ...);
int cfd = accpet(lfd, ...); //阻塞
read(cfd,...); /recv(cfd,...); //阻塞
```
即遇到read/write/accept时，阻塞等待，直到有数据或连接时才继续执行。  

- 好处：不占用CPU宝贵的时间片
- 缺点：同一时刻只能处理一个操作，效率低
- 克服缺点： 多线程或多进程解决，一个线程/进程对应一个任务
![socket调用过程](/img/socket.png)

### 多任务

**多进程/线程模型**
基于最原始的阻塞网络IO，如果服务器要支持多个客户端，其中比较传统的方式即使用多进程模型，即为每个客户端分配一个进程/线程来处理请求。
- 优点：能够同时处理多个任务，一个线程/进程对应一个任务
- 缺点：
    - 线程或进程会消耗资源
    - 线程或进程调度会消耗CPU资源
- 根本问题：阻塞  

## 非阻塞，忙轮询（NIO模型）
---
线程可以不需要阻塞在某个函数上，可以继续往下执行，但需要不断轮询资源是否到达
```c++
int lfd = socket(...);
bind(lfd, ...);
listen(lfd, ...);
int cfd = accpet(lfd, ...); //非阻塞
read(cfd,...); /recv(cfd,...); //非阻塞
```
此时accpet是非阻塞的，当没有连接进来时，可以进行下面的操作(不能进行read,recv; 但如果有待处理的连接，则可以处理待处理连接的read和recv，类似于多路复用)。  

- 优点：提高了程序的执行效率
- 缺点：需要占用更多的CPU和系统资源，每循环都需要 O(n) 系统调用（用来查找哪个任务可执行）
- 克服缺点：使用IO多路转接技术select/poll/epoll

## IO多路复用
既然为每个请求分配一个进程/线程不合适，那么有没有可能只用一个进程来维护多个socket？ 那就是使用「IO多路复用」
![IO多路复用](/img/IOmulti.jpg)  

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时在1毫秒内，这样1秒内就能处理上千个请求，把时间拉长来看，多个请求复用一个进程，这就是多路复用。这种思想很类似一个CPU并发多个进程，所以也叫做时分多路复用。  

select/poll/epoll 内核提供给用户态多路复用调用， **进程可以通过一个系统调用函数从内核从获取多个事件。**  

select/poll/epoll是如何获取网络事件的？ 在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。  

### select/poll
---
select实现多路复用的方式是，将已连接的socket都放在一个**文件描述符集合**，然后调用select将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此socket标记为可读可写，接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还要再通过**遍历**的方式找到可读或可写的socket，然后再对其处理。
![select](/img/select.jpg)  

select的缺点显而易见：
- 需要2次「遍历」文件描述符集合，一次在内核态，一次在用户态；2次「拷贝」文件描述符集合。在文件描述符很多时，这个开销很大
- select支持的文件描述符数量太小，默认是1024  
- 文件描述符集合不能重用，因为每次会把变动的结果拷贝到用户态，而下次再需要监听时需要重置。  

poll不再使用固定长度的bitsMap，而是使用动态数组、链表形式来组织，突破了select的文件描述符个数限制，但仍然会受到系统文件描述符限制  

poll和select没有太大的本质区别，都是使用「线性结构」存储进程关注的socket集合，因此都要遍历文件描述符集合来找到可读或可写的socket，时间复杂度为O(N)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

### epoll  
---

这里先偷个懒直接看下面的链接吧


## 参考链接
![I/O多路复用：select/poll/epoll](https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#最基本的-socket-模型)
![彻底搞懂IO多路复用](https://zhuanlan.zhihu.com/p/602256078)
