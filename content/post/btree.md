---
title:       "B树和B+树"
subtitle:    ""
description: ""
date:        2023-07-12T21:31:25+08:00 
author:      ""
image:       ""
tags:        ["mysql"]
categories:  ["Tech" ]
katex:       false
---

# B树
## 一、什么是B树
B(balance)树是一种多路自平衡的搜索树，类似普通的平衡二叉搜索树，不同的是B树允许每个节点有更多的子节点

![B树](/img/BTree.jpg)  

B树的特点：
1. 索引值和对应的data在同一节点中
2. 每个关键字出现且只出现在一个结点中
3. 搜索效率不稳定（最好情况在第一层就能找到数据，即O(1)）
4. 在关键字全集内做一次查找，性能逼近二分查找
5. K个子树的中间结点包含k-1个元素
6. 根节点非叶结点关键字个数 1 ≤ key ≤ m - 1, 非根非叶节点关键字个数 ceil(m/2) - 1 ≤ key ≤ m - 1。

## 二、B树的设计
我们从“迎合”磁盘的角度来看B树的设计：

索引的效率依赖于磁盘IO的次数，快速索引需要有效减少磁盘IO次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围，而平衡二叉树便是每次将范围缩小一半，最后只需要搜索log2n的数据。

为了能够更快，B树每次将范围分割为多个区间，区间越多，定位数据越快越精确。新建节点时，直接申请页大小的空间（磁盘存储单位是按block分的，一般为512Byte。磁盘IO一次读取若干个block，我们称为一页），计算机内存分配是按页对齐的，这样每次读取一个节点只需要一次IO。

而多叉的好处就是，每次将范围分成k份，这样只需要搜索logk n的数据，有效降低了B树的高度，进而也降低了磁盘IO的次数

## 三、B树的操作  

### 查找  
假设每个节点有n个key值，被分割成n + 1个区间，每个key值紧跟着data域。一般而言，根节点都在内存中，B树以每个节点为一次磁盘IO  

![B树](/img/BTree.jpg)  

以上图为例，若搜索key为11的data，首先在根节点进行二分查找，因为key < 25, 定位到最左侧的节点，此时进行一次磁盘IO，将节点从磁盘读入内存。接着上述过程，查找到该key为止。
```c++
Data* BTreeSearch(Root *node, Key key)
{
    Data* data;

    if(root == NULL)
        return NULL;
    data = BinarySearch(node);
    if(data->key == key)
    {
        return data;
    }else{
        node = ReadDisk(data->next);
        BTreeSearch(node, key);
    }
}
```

### 插入
**插入规则**
- 当前节点key的个数 < m - 1,直接插入
- 当前节点key的个数 ≥ m - 1, 以节点中间的key将节点分为左右两部分，中间结点上浮到父结点。

![B树](/img/BTree_insert.jpg)  

### 删除
B树的删除操作比插入操作复杂

**删除规则：**

- 删除叶子结点：当删除后，节点数仍大于 m / 2，直接删除
- 删除叶子结点：当删除后，节点数 < m / 2，并且他的兄弟结点节点数 > m / 2， 那就先将父结点的元素移到当前节点，然后将兄弟结点的元素上浮到父结点
- 删除叶子结点：当删除后，节点数 < m / 2,并且兄弟结点数不够借，那么先将父结点元素移到该节点，然后合并兄弟结点。
- 删除非叶子结点：用后继元素覆盖要删除的元素，然后在后继key所在的子支删除该后继key  

# B+树

## 一、什么是B+树
B+树是B树的变体，也是一种多路搜索树。

相同点：

- 根节点至少一个元素

不同点：

- 所有关键字存储在叶子结点，每个非叶子结点只存储key
- 为所有叶子结点增加一个链指针
- k个分支对应k个关键字  

![B+树](/img/BTree_plus.jpg)   

由于B+树的每个非叶子结点只存储key用于索引，所有数据存在叶子结点中，所以每个节点能存储的key就比B树更多，每一层可以容纳更多的元素，也就是磁盘中的每一页可以存放更多的元素，这样就能减少查找时的IO次数。

同时，B+树由于data域在叶子结点上，所以每次查找效率均为logn，查找稳定  

## 二、B+树的操作  
插入删除操作同B树类似，注意每次插入删除保证结点数符合要求即可。要求我会放在最后一张图上。  

# B树和B+树的区别

- B+树内非叶子结点不存储数据，所有data存储在叶结点，查找时间复杂度固定在log n；而B树查询时间复杂度不固定，与key在树中的位置有关，最好为O(1)。
- B+树在叶子节点加入了链表，可进行范围搜索，也可很好的利用局部性原理，在读取一个节点的时候将周围节点也读入内存。
- B+树更适合外部存储，非叶子结点无data域，每个节点能索引的范围更大更精确  

![区别](/img/BTree_different.png)  

# 参考链接  

[B树和B+树的区别](http://t.csdn.cn/ckubh)  

[面试官问你B树和B+树，就把这篇文章丢给他](https://segmentfault.com/a/1190000020416577)