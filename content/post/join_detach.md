---
title:       "join 和 detach"
subtitle:    ""
description: ""
date:        2023-07-02T14:40:55+08:00 
author:      ""
image:       ""
tags:        ["网络编程"]
categories:  ["Tech" ]
katex:       false
---

在thread对象构造完成（线程开始执行）之后，对象析构之前，我们必须选择是等待它（join）或者让它在后台运行（detach），如果thread对象在析构前没有这么做，那么线程就会终止，因为thread的析构函数中调用了'std::terminate()'
- detach使得即使thread对象析构，线程也能继续运行，但是注意，我们要确保线程结束之前它所访问的数据都是有效的
- 调用thread对象的join方法，函数将等待线程完成，然后继续执行后续语句。join将清理线程相关的存储空间
### 可会合(join)
在这种关系下，主线程需要明确执行等待操作，在子线程结束后，主线程的等待操作执行完毕，子线程和主线程会合，这时主线程继续执行等待操作之后的下一步操作。主线程必须会合可会合的子线程。在主线程的线程函数内调用子线程对象的wait函数实现，即使子线程能够在主线程之前执行完毕，进入终止态，也必须执行会合操作，否则系统永远不会主动销毁线程，分配给该线程的系统资源也永远不会释放

### 相分离(detach)
表示子线程无需和主线程会合，也就是相分离的，这种情况下，子线程一旦进入终止状态，这种方式常用在线程较多的情况下，有时让主线程逐个等待子线程结束，或者让主线程安排每个子线程结束的等待顺序，是很困难活  

在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached），一个可结合的线程能够被其他线程回收资源和杀死，在被其他线程回收之前，它的存储器资源如栈，是不释放的，相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。thread对象只能join或detach一次，否则就会返回false