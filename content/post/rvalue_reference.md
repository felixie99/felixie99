---
title:       "右值引用"
subtitle:    ""
description: ""
date:        2023-05-27T21:28:46+08:00
author:      ""
image:       ""
tags:        ["cpp"]
categories:  ["Tech" ]
---

# 右值引用
为了支持移动操作，新标准引入了新的引用类型------**右值引用(rvalue reference)**  
我们通过&&而不是&来获得右值引用，**右值引用有一个重要的性质------只能绑定到一个将要销毁的对象**。
> 将要销毁的对象：如  
> - **临时对象**:临时对象是表达式中创建但不会被赋予变量名的对象。它们的生命周期只在其所在的完整表达式中，一旦表达式结束，这些对象就会被销毁。如，std::string("hello")就创建了一个临时的std::string对象; 算术、关系、位以及后置递增/递减运算符，都生成右值
> - **函数返回值**:如果一个函数的返回值是通过值返回的（即不是指针或引用）， 那么这个返回值在函数调用结束后就是一个右值。
例如,如果有一个函数std::string get_hello() {return "hello";}, 那么在std::string s = get_hello(),这样的语句中，get_hello()返回的就是一个右值
> - **标准库中定义的std::move**:std::move可以将一个左值转化为右值，这意味着std::move可以使得一个对象被视为即将被销毁，从而允许它被右值引用绑定，即使这个对象的生命周期并没有结束。

由于右值只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。  

左值表达式表示的一个对象的身份，而右值表达式表示的是一个对象的值，如：
```c++
int i = 42; //42是右值， i是左值
```

左值引用是某个对象的另一个名字，而右值引用也不过是某个对象的另一个名字。  
左值引用不能绑定到要求转换的表达式、字面常量或是返回右值的表达式  
右值引用可以绑定上述表达式，但不能直接绑定到一个左值
```c++
int i = 42; //ok
int &r = i; //ok,左值引用绑定左值
int &&rr = i; //false,不能将一个右值引用直接绑定到一个左值
int &r2 = i * 42; //false, i * 42时一个右值
const int &r3 = i * 42; //ok, 可以将一个const的引用绑定到一个右值上
int &&r2 = i * 42; //ok, 可以将右值引用绑定到右值  
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都返回左值，可以将左值引用绑定到这类表达式上。  
返回非引用类型的函数，算术、关系、位以及后置递增/递减运算符,都生成右值。

注意！ 变量表达式都是左值，变量表达式可以看作一个运算对象而没有运算符的表达式  
所以我们不能将一个右值引用绑定到一个右值引用类型的变量上：
```c++
int &&rr1 = 42; //ok,字面常量是右值
int &&rr2 = rr1; //false， 表达式rr1是左值
```
因为rr1是变量，而变量只有在离开作用域时才销毁，所以rr1是持久的 是左值

**总结：左值持久，右值短暂**
左值在离开作用域后被销毁，右值在语句结束后销毁