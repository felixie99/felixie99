---
title:       "右值引用"
subtitle:    ""
description: ""
date:        2023-05-27T21:28:46+08:00
author:      ""
image:       ""
tags:        ["cpp"]
categories:  ["Tech" ]
---
# 移动语义
在很多情况下会发生对象拷贝，但是对象拷贝后就立即被立即销毁了。在这种情况下使用移动而非拷贝对象会大幅度提升性能
使用移动的另一个原因是某些对象不能被拷贝只能被移动，如IO类或unique_ptr这样的类，这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这类对象不能被拷贝但可以移动。  

为了支持移动操作引入的类型
- 右值引用
- 移动构造函数和移动赋值函数  

# 右值引用
为了支持移动操作，新标准引入了新的引用类型------**右值引用(rvalue reference)**  
我们通过&&而不是&来获得右值引用，**右值引用有一个重要的性质------只能绑定到一个将要销毁的对象**。
> 将要销毁的对象：如  
> - **临时对象**:临时对象是表达式中创建但不会被赋予变量名的对象。它们的生命周期只在其所在的完整表达式中，一旦表达式结束，这些对象就会被销毁。如，std::string("hello")就创建了一个临时的std::string对象; 算术、关系、位以及后置递增/递减运算符，都生成右值
> - **函数返回值**:如果一个函数的返回值是通过值返回的（即不是指针或引用）， 那么这个返回值在函数调用结束后就是一个右值。
例如,如果有一个函数std::string get_hello() {return "hello";}, 那么在std::string s = get_hello(),这样的语句中，get_hello()返回的就是一个右值
> - **标准库中定义的std::move**:可以将一个左值转化为右值，这意味着std::move可以使得一个对象被视为即将被销毁，从而允许它被右值引用绑定，即使这个对象的生命周期并没有结束。

由于右值只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。  

左值表达式表示的一个对象的身份，而右值表达式表示的是一个对象的值，如：
```c++
int i = 42; //42是右值， i是左值
```

左值引用是某个对象的另一个名字，而右值引用也不过是某个对象的另一个名字。  
左值引用不能绑定到要求转换的表达式、字面常量或是返回右值的表达式  
右值引用可以绑定上述表达式，但不能直接绑定到一个左值(因为右值是一个将要销毁的值，把一个将要销毁的值绑定到左值上，就能修改一个将要销毁的对象，这可能导致错误的结果)
```c++
int i = 42; //ok
int &r = i; //ok,左值引用绑定左值
int &&rr = i; //false,不能将一个右值引用直接绑定到一个左值
int &r2 = i * 42; //false, i * 42时一个右值
const int &r3 = i * 42; //ok, 可以将一个const的引用绑定到一个右值上
int &&r2 = i * 42; //ok, 可以将右值引用绑定到右值  
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都返回左值，可以将左值引用绑定到这类表达式上。  
返回非引用类型的函数，算术、关系、位以及后置递增/递减运算符,都生成右值。

注意！ 变量表达式都是左值，变量表达式可以看作一个运算对象而没有运算符的表达式  
所以我们不能将一个右值引用绑定到一个右值引用类型的变量上：
```c++
int &&rr1 = 42; //ok,字面常量是右值
int &&rr2 = rr1; //false， 表达式rr1是左值
```
因为rr1是变量，而变量只有在离开作用域时才销毁，所以rr1是持久的 是左值

**总结：左值持久，右值短暂**
左值在离开作用域后被销毁，右值在语句结束后销毁

# 移动构造函数和移动赋值运算符
这两个成员类似对应的拷贝操作，但他们从给定对象“窃取”资源而不是拷贝资源。  

除了完成资源移动，移动构造函数还必须确保移后源对象处于「销毁它是无害的」的状态，以保证。同时，资源移动完成后，源对象就不能再指向被移动的资源，这些资源的所有权已经归属新创建的对象。用人话说就是，转移了所有权之后，要确保两个对象没有任何关系也没有任何影响。比如要将源对象的指针置为nullptr，防止析构后将已经转移资源也释放了。

这两个成员都不应该抛出异常，即需要加上noexcept。  
例如vector的push_back操作，如果在push_back时需要进行扩容，使用移动操作，而移动到一半时抛出异常，此时移动源元素已经改变，而新空间中未构造的元素可能尚不存在，这就会造成危险。
如果不将移动操作标记为noexcept，告诉vector用这个移动构造函数不会出错，那vector就会选择拷贝构造而不是移动拷贝构造。
看看代码：
```c++
class Str{
public:
    Str(Str&&) noexcept;
    Str &operator=(Str&& rhs) noexcept;
}
```

## 合成的移动操作
与拷贝操作不同，如果我们不声明自己的移动操作，编译器根本不会为某些类合成移动操作。特别是，一个类定义了自己的拷贝构造函数、拷贝复制运算符或者析构函数，编译器就不会为它合成移动构造和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。  

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。